import { WebSocketServer, WebSocket } from 'ws';

declare function init(): void;

type MessageReceiveCallback$1 = (message: string) => void;
declare class WebSocketServerController {
    wss: WebSocketServer;
    onMessage: MessageReceiveCallback$1;
    constructor(port?: number, onMessage?: MessageReceiveCallback$1);
    AddMessageOnConection(message: string): void;
    BroadcastMessage(message: string): void;
}

type MessageReceiveCallback = (message: string) => void;
declare class WebSocketClientController {
    ws: WebSocket;
    onMessage: MessageReceiveCallback;
    constructor(url: string, onMessage?: MessageReceiveCallback);
    SendMessage(message: string): void;
}

declare function parseMessage(json: any): any;

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * GAS: Identifier for Commodity GAS
 * HEAT: Identifier for Commodity HEAT
 * ELECTRICITY: Identifier for Commodity ELECTRICITY
 * OIL: Identifier for Commodity OIL
 */
type Commodity$3 = "GAS" | "HEAT" | "ELECTRICITY" | "OIL";

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ELECTRIC.POWER.L1: Electric power described in Watt on phase 1. If a device utilizes only one phase it should always use L1.
 * ELECTRIC.POWER.L2: Electric power described in Watt on phase 2. Only applicable for 3 phase devices.
 * ELECTRIC.POWER.L3: Electric power described in Watt on phase 3. Only applicable for 3 phase devices.
 * ELECTRIC.POWER.3_PHASE_SYMMETRIC: Electric power described in Watt on when power is equally shared among the three phases. Only applicable for 3 phase devices.
 * NATURAL_GAS.FLOW_RATE: Gas flow rate described in liters per second
 * HYDROGEN.FLOW_RATE: Gas flow rate described in grams per second
 * HEAT.TEMPERATURE: Heat described in degrees Celsius
 * HEAT.FLOW_RATE: Flow rate of heat carrying gas or liquid in liters per second
 * HEAT.THERMAL_POWER: Thermal power in Watt
 * OIL.FLOW_RATE: Oil flow rate described in liters per hour
 */
type CommodityQuantity$a = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * An identifier expressed as a UUID
 */
type ID$l = string;

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
interface NumberRange$9 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * The power quantity the value refers to
 */
type CommodityQuantity$9 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface PowerForecastValue$3 {
    /**
     * The upper boundary of the range with 100 % certainty the power value is in it
     */
    value_upper_limit?: number;
    /**
     * The upper boundary of the range with 95 % certainty the power value is in it
     */
    value_upper_95PPR?: number;
    /**
     * The upper boundary of the range with 68 % certainty the power value is in it
     */
    value_upper_68PPR?: number;
    /**
     * The expected power value.
     */
    value_expected: number;
    /**
     * The lower boundary of the range with 68 % certainty the power value is in it
     */
    value_lower_68PPR?: number;
    /**
     * The lower boundary of the range with 95 % certainty the power value is in it
     */
    value_lower_95PPR?: number;
    /**
     * The lower boundary of the range with 100 % certainty the power value is in it
     */
    value_lower_limit?: number;
    commodity_quantity: CommodityQuantity$9;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * Duration of the PowerForecastElement
 */
type Duration$a = number;
/**
 * The power quantity the value refers to
 */
type CommodityQuantity$8 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface PowerForecastElement$2 {
    duration: Duration$a;
    /**
     * The values of power that are expected for the given period of time. There shall be at least one PowerForecastValue, and at most one PowerForecastValue per CommodityQuantity.
     *
     * @minItems 1
     * @maxItems 10
     */
    power_values: [PowerForecastValue$2] | [PowerForecastValue$2, PowerForecastValue$2] | [PowerForecastValue$2, PowerForecastValue$2, PowerForecastValue$2] | [PowerForecastValue$2, PowerForecastValue$2, PowerForecastValue$2, PowerForecastValue$2] | [PowerForecastValue$2, PowerForecastValue$2, PowerForecastValue$2, PowerForecastValue$2, PowerForecastValue$2] | [
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2
    ] | [
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2
    ] | [
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2
    ] | [
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2
    ] | [
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2,
        PowerForecastValue$2
    ];
}
interface PowerForecastValue$2 {
    /**
     * The upper boundary of the range with 100 % certainty the power value is in it
     */
    value_upper_limit?: number;
    /**
     * The upper boundary of the range with 95 % certainty the power value is in it
     */
    value_upper_95PPR?: number;
    /**
     * The upper boundary of the range with 68 % certainty the power value is in it
     */
    value_upper_68PPR?: number;
    /**
     * The expected power value.
     */
    value_expected: number;
    /**
     * The lower boundary of the range with 68 % certainty the power value is in it
     */
    value_lower_68PPR?: number;
    /**
     * The lower boundary of the range with 95 % certainty the power value is in it
     */
    value_lower_95PPR?: number;
    /**
     * The lower boundary of the range with 100 % certainty the power value is in it
     */
    value_lower_limit?: number;
    commodity_quantity: CommodityQuantity$8;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * The power quantity the values refer to
 */
type CommodityQuantity$7 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface PowerRange$4 {
    /**
     * Power value that defines the start of the range.
     */
    start_of_range: number;
    /**
     * Power value that defines the end of the range.
     */
    end_of_range: number;
    commodity_quantity: CommodityQuantity$7;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * The power quantity the value refers to
 */
type CommodityQuantity$6 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface PowerValue$1 {
    commodity_quantity: CommodityQuantity$6;
    /**
     * Power value expressed in the unit associated with the CommodityQuantity
     */
    value: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * Role type of the Resource Manager for the given commodity
 */
type RoleType$1 = "ENERGY_PRODUCER" | "ENERGY_CONSUMER" | "ENERGY_STORAGE";
/**
 * Commodity the role refers to.
 */
type Commodity$2 = "GAS" | "HEAT" | "ELECTRICITY" | "OIL";
interface Role$1 {
    role: RoleType$1;
    commodity: Commodity$2;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of the Timer. Must be unique in the scope of the OMBC.SystemDescription, FRBC.ActuatorDescription or DDBC.ActuatorDescription in which it is used.
 */
type ID$k = string;
/**
 * The time it takes for the Timer to finish after it has been started
 */
type Duration$9 = number;
interface Timer$2 {
    id: ID$k;
    /**
     * Human readable name/description of the Timer. This element is only intended for diagnostic purposes and not for HMI applications.
     */
    diagnostic_label?: string;
    duration: Duration$9;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of the Transition. Must be unique in the scope of the OMBC.SystemDescription, FRBC.ActuatorDescription or DDBC.ActuatorDescription in which it is used.
 */
type ID$j = string;
/**
 * ID of the OperationMode (exact type differs per ControlType) that should be switched from.
 */
type ID1$7 = string;
/**
 * ID of the OperationMode (exact type differs per ControlType) that will be switched to.
 */
type ID2$4 = string;
/**
 * An identifier expressed as a UUID
 */
type ID3$3 = string;
/**
 * Indicates the time between the initiation of this Transition, and the time at which the device behaves according to the Operation Mode which is defined in the ‘to’ data element. When no value is provided it is assumed the transition duration is negligible.
 */
type Duration$8 = number;
interface Transition$2 {
    id: ID$j;
    from: ID1$7;
    to: ID2$4;
    /**
     * List of IDs of Timers that will be (re)started when this transition is initiated
     *
     * @minItems 0
     * @maxItems 1000
     */
    start_timers: ID3$3[];
    /**
     * List of IDs of Timers that block this Transition from initiating while at least one of these Timers is not yet finished
     *
     * @minItems 0
     * @maxItems 1000
     */
    blocking_timers: ID3$3[];
    /**
     * Absolute costs for going through this Transition in the currency as described in the ResourceManagerDetails.
     */
    transition_costs?: number;
    transition_duration?: Duration$8;
    /**
     * Indicates if this Transition may only be used during an abnormal condition (see Clause )
     */
    abnormal_condition_only: boolean;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * POWER_ENVELOPE_BASED_CONTROL: Identifier for the Power Envelope Based Control type
 * POWER_PROFILE_BASED_CONTROL: Identifier for the Power Profile Based Control type
 * OPERATION_MODE_BASED_CONTROL: Identifier for the Operation Mode Based Control type
 * FILL_RATE_BASED_CONTROL: Identifier for the Demand Driven Based Control type
 * DEMAND_DRIVEN_BASED_CONTROL: Identifier for the Fill Rate Based Control type
 * NOT_CONTROLABLE: Identifier that is to be used if no control is possible. Resources of this type can still provide measurements and forecast
 * NO_SELECTION: Identifier that is to be used if no control type is or has been selected.
 */
type ControlType$2 = "POWER_ENVELOPE_BASED_CONTROL" | "POWER_PROFILE_BASED_CONTROL" | "OPERATION_MODE_BASED_CONTROL" | "FILL_RATE_BASED_CONTROL" | "DEMAND_DRIVEN_BASED_CONTROL" | "NOT_CONTROLABLE" | "NO_SELECTION";

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * Currency used when this resource gives cost information
 */
type Currency$1 = "AED" | "ANG" | "AUD" | "CHE" | "CHF" | "CHW" | "EUR" | "GBP" | "LBP" | "LKR" | "LRD" | "LSL" | "LYD" | "MAD" | "MDL" | "MGA" | "MKD" | "MMK" | "MNT" | "MOP" | "MRO" | "MUR" | "MVR" | "MWK" | "MXN" | "MXV" | "MYR" | "MZN" | "NAD" | "NGN" | "NIO" | "NOK" | "NPR" | "NZD" | "OMR" | "PAB" | "PEN" | "PGK" | "PHP" | "PKR" | "PLN" | "PYG" | "QAR" | "RON" | "RSD" | "RUB" | "RWF" | "SAR" | "SBD" | "SCR" | "SDG" | "SEK" | "SGD" | "SHP" | "SLL" | "SOS" | "SRD" | "SSP" | "STD" | "SYP" | "SZL" | "THB" | "TJS" | "TMT" | "TND" | "TOP" | "TRY" | "TTD" | "TWD" | "TZS" | "UAH" | "UGX" | "USD" | "USN" | "UYI" | "UYU" | "UZS" | "VEF" | "VND" | "VUV" | "WST" | "XAG" | "XAU" | "XBA" | "XBB" | "XBC" | "XBD" | "XCD" | "XOF" | "XPD" | "XPF" | "XPT" | "XSU" | "XTS" | "XUA" | "XXX" | "YER" | "ZAR" | "ZMW" | "ZWL";

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of the Actuator. Must be unique in the scope of the Resource Manager, for at least the duration of the session between Resource Manager and CEM.
 */
type ID$i = string;
/**
 * GAS: Identifier for Commodity GAS
 * HEAT: Identifier for Commodity HEAT
 * ELECTRICITY: Identifier for Commodity ELECTRICITY
 * OIL: Identifier for Commodity OIL
 */
type Commodity$1 = "GAS" | "HEAT" | "ELECTRICITY" | "OIL";
/**
 * ID of the FRBC.OperationMode. Must be unique in the scope of the FRBC.ActuatorDescription in which it is used.
 */
type ID1$6 = string;
/**
 * The power quantity the values refer to
 */
type CommodityQuantity$5 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
/**
 * ID of the Transition. Must be unique in the scope of the OMBC.SystemDescription, FRBC.ActuatorDescription or DDBC.ActuatorDescription in which it is used.
 */
type ID2$3 = string;
/**
 * ID of the OperationMode (exact type differs per ControlType) that should be switched from.
 */
type ID3$2 = string;
/**
 * ID of the OperationMode (exact type differs per ControlType) that will be switched to.
 */
type ID4 = string;
/**
 * An identifier expressed as a UUID
 */
type ID5 = string;
/**
 * Indicates the time between the initiation of this Transition, and the time at which the device behaves according to the Operation Mode which is defined in the ‘to’ data element. When no value is provided it is assumed the transition duration is negligible.
 */
type Duration$7 = number;
/**
 * An identifier expressed as a UUID
 */
type ID6 = string;
/**
 * The time it takes for the Timer to finish after it has been started
 */
type Duration1 = number;
interface FRBC_ActuatorDescription {
    id: ID$i;
    /**
     * Human readable name/description for the actuator. This element is only intended for diagnostic purposes and not for HMI applications.
     */
    diagnostic_label?: string;
    /**
     * List of all supported Commodities.
     *
     * @minItems 1
     * @maxItems 4
     */
    supported_commodities: [Commodity$1] | [Commodity$1, Commodity$1] | [Commodity$1, Commodity$1, Commodity$1] | [Commodity$1, Commodity$1, Commodity$1, Commodity$1];
    /**
     * Provided FRBC.OperationModes associated with this actuator
     *
     * @minItems 1
     * @maxItems 100
     */
    operation_modes: [FRBC_OperationMode$1, ...FRBC_OperationMode$1[]];
    /**
     * Possible transitions between FRBC.OperationModes associated with this actuator.
     *
     * @minItems 0
     * @maxItems 1000
     */
    transitions: Transition$1[];
    /**
     * List of Timers associated with this actuator
     *
     * @minItems 0
     * @maxItems 1000
     */
    timers: Timer$1[];
}
interface FRBC_OperationMode$1 {
    id: ID1$6;
    /**
     * Human readable name/description of the FRBC.OperationMode. This element is only intended for diagnostic purposes and not for HMI applications.
     */
    diagnostic_label?: string;
    /**
     * List of FRBC.OperationModeElements, which describe the properties of this FRBC.OperationMode depending on the fill_level. The fill_level_ranges of the items in the Array must be contiguous.
     *
     * @minItems 1
     * @maxItems 100
     */
    elements: [FRBC_OperationModeElement$2, ...FRBC_OperationModeElement$2[]];
    /**
     * Indicates if this FRBC.OperationMode may only be used during an abnormal condition
     */
    abnormal_condition_only: boolean;
}
interface FRBC_OperationModeElement$2 {
    fill_level_range: NumberRange$8;
    fill_rate: NumberRange1$2;
    /**
     * The power produced or consumed by this operation mode. The start of each PowerRange is associated with an operation_mode_factor of 0, the end is associated with an operation_mode_factor of 1. In the array there must be at least one PowerRange, and at most one PowerRange per CommodityQuantity.
     *
     * @minItems 1
     * @maxItems 10
     */
    power_ranges: [PowerRange$3] | [PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3] | [PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3, PowerRange$3] | [
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3,
        PowerRange$3
    ];
    running_costs?: NumberRange2$2;
}
/**
 * The range of the fill level for which this FRBC.OperationModeElement applies. The start of the NumberRange shall be smaller than the end of the NumberRange.
 */
interface NumberRange$8 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
/**
 * Indicates the change in fill_level per second. The lower_boundary of the NumberRange is associated with an operation_mode_factor of 0, the upper_boundary is associated with an operation_mode_factor of 1.
 */
interface NumberRange1$2 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
interface PowerRange$3 {
    /**
     * Power value that defines the start of the range.
     */
    start_of_range: number;
    /**
     * Power value that defines the end of the range.
     */
    end_of_range: number;
    commodity_quantity: CommodityQuantity$5;
}
/**
 * Additional costs per second (e.g. wear, services) associated with this operation mode in the currency defined by the ResourceManagerDetails, excluding the commodity cost. The range is expressing uncertainty and is not linked to the operation_mode_factor.
 */
interface NumberRange2$2 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
interface Transition$1 {
    id: ID2$3;
    from: ID3$2;
    to: ID4;
    /**
     * List of IDs of Timers that will be (re)started when this transition is initiated
     *
     * @minItems 0
     * @maxItems 1000
     */
    start_timers: ID5[];
    /**
     * List of IDs of Timers that block this Transition from initiating while at least one of these Timers is not yet finished
     *
     * @minItems 0
     * @maxItems 1000
     */
    blocking_timers: ID5[];
    /**
     * Absolute costs for going through this Transition in the currency as described in the ResourceManagerDetails.
     */
    transition_costs?: number;
    transition_duration?: Duration$7;
    /**
     * Indicates if this Transition may only be used during an abnormal condition (see Clause )
     */
    abnormal_condition_only: boolean;
}
interface Timer$1 {
    id: ID6;
    /**
     * Human readable name/description of the Timer. This element is only intended for diagnostic purposes and not for HMI applications.
     */
    diagnostic_label?: string;
    duration: Duration1;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * The duration of the element.
 */
type Duration$6 = number;
interface FRBC_FillLevelTargetProfileElement$1 {
    duration: Duration$6;
    fill_level_range: NumberRange$7;
}
/**
 * The target range in which the fill_level must be for the time period during which the element is active. The start of the range must be smaller or equal to the end of the range. The CEM must take best-effort actions to proactively achieve this target.
 */
interface NumberRange$7 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
interface FRBC_LeakageBehaviourElement$1 {
    fill_level_range: NumberRange$6;
    /**
     * Indicates how fast the momentary fill level will decrease per second due to leakage within the given range of the fill level. A positive value indicates that the fill level decreases over time due to leakage.
     */
    leakage_rate: number;
}
/**
 * The fill level range for which this FRBC.LeakageBehaviourElement applies. The start of the range must be less than the end of the range.
 */
interface NumberRange$6 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of the FRBC.OperationMode. Must be unique in the scope of the FRBC.ActuatorDescription in which it is used.
 */
type ID$h = string;
/**
 * The power quantity the values refer to
 */
type CommodityQuantity$4 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface FRBC_OperationMode {
    id: ID$h;
    /**
     * Human readable name/description of the FRBC.OperationMode. This element is only intended for diagnostic purposes and not for HMI applications.
     */
    diagnostic_label?: string;
    /**
     * List of FRBC.OperationModeElements, which describe the properties of this FRBC.OperationMode depending on the fill_level. The fill_level_ranges of the items in the Array must be contiguous.
     *
     * @minItems 1
     * @maxItems 100
     */
    elements: [FRBC_OperationModeElement$1, ...FRBC_OperationModeElement$1[]];
    /**
     * Indicates if this FRBC.OperationMode may only be used during an abnormal condition
     */
    abnormal_condition_only: boolean;
}
interface FRBC_OperationModeElement$1 {
    fill_level_range: NumberRange$5;
    fill_rate: NumberRange1$1;
    /**
     * The power produced or consumed by this operation mode. The start of each PowerRange is associated with an operation_mode_factor of 0, the end is associated with an operation_mode_factor of 1. In the array there must be at least one PowerRange, and at most one PowerRange per CommodityQuantity.
     *
     * @minItems 1
     * @maxItems 10
     */
    power_ranges: [PowerRange$2] | [PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2] | [PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2, PowerRange$2] | [
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2,
        PowerRange$2
    ];
    running_costs?: NumberRange2$1;
}
/**
 * The range of the fill level for which this FRBC.OperationModeElement applies. The start of the NumberRange shall be smaller than the end of the NumberRange.
 */
interface NumberRange$5 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
/**
 * Indicates the change in fill_level per second. The lower_boundary of the NumberRange is associated with an operation_mode_factor of 0, the upper_boundary is associated with an operation_mode_factor of 1.
 */
interface NumberRange1$1 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
interface PowerRange$2 {
    /**
     * Power value that defines the start of the range.
     */
    start_of_range: number;
    /**
     * Power value that defines the end of the range.
     */
    end_of_range: number;
    commodity_quantity: CommodityQuantity$4;
}
/**
 * Additional costs per second (e.g. wear, services) associated with this operation mode in the currency defined by the ResourceManagerDetails, excluding the commodity cost. The range is expressing uncertainty and is not linked to the operation_mode_factor.
 */
interface NumberRange2$1 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * The power quantity the values refer to
 */
type CommodityQuantity$3 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface FRBC_OperationModeElement {
    fill_level_range: NumberRange$4;
    fill_rate: NumberRange1;
    /**
     * The power produced or consumed by this operation mode. The start of each PowerRange is associated with an operation_mode_factor of 0, the end is associated with an operation_mode_factor of 1. In the array there must be at least one PowerRange, and at most one PowerRange per CommodityQuantity.
     *
     * @minItems 1
     * @maxItems 10
     */
    power_ranges: [PowerRange$1] | [PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1] | [PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1, PowerRange$1] | [
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1,
        PowerRange$1
    ];
    running_costs?: NumberRange2;
}
/**
 * The range of the fill level for which this FRBC.OperationModeElement applies. The start of the NumberRange shall be smaller than the end of the NumberRange.
 */
interface NumberRange$4 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
/**
 * Indicates the change in fill_level per second. The lower_boundary of the NumberRange is associated with an operation_mode_factor of 0, the upper_boundary is associated with an operation_mode_factor of 1.
 */
interface NumberRange1 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}
interface PowerRange$1 {
    /**
     * Power value that defines the start of the range.
     */
    start_of_range: number;
    /**
     * Power value that defines the end of the range.
     */
    end_of_range: number;
    commodity_quantity: CommodityQuantity$3;
}
/**
 * Additional costs per second (e.g. wear, services) associated with this operation mode in the currency defined by the ResourceManagerDetails, excluding the commodity cost. The range is expressing uncertainty and is not linked to the operation_mode_factor.
 */
interface NumberRange2 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
interface FRBC_StorageDescription {
    /**
     * Human readable name/description of the storage (e.g. hot water buffer or battery). This element is only intended for diagnostic purposes and not for HMI applications.
     */
    diagnostic_label?: string;
    /**
     * Human readable description of the (physical) units associated with the fill_level (e.g. degrees Celsius or percentage state of charge). This element is only intended for diagnostic purposes and not for HMI applications.
     */
    fill_level_label?: string;
    /**
     * Indicates whether the Storage could provide details of power leakage behaviour through the FRBC.LeakageBehaviour.
     */
    provides_leakage_behaviour: boolean;
    /**
     * Indicates whether the Storage could provide a target profile for the fill level through the FRBC.FillLevelTargetProfile.
     */
    provides_fill_level_target_profile: boolean;
    /**
     * Indicates whether the Storage could provide a UsageForecast through the FRBC.UsageForecast.
     */
    provides_usage_forecast: boolean;
    fill_level_range: NumberRange$3;
}
/**
 * The range in which the fill_level should remain. It is expected of the CEM to keep the fill_level within this range. When the fill_level is not within this range, the Resource Manager can ignore instructions from the CEM (except during abnormal conditions).
 */
interface NumberRange$3 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * Indicator for how long the given usage_rate is valid.
 */
type Duration$5 = number;
interface FRBC_UsageForecastElement$1 {
    duration: Duration$5;
    /**
     * The upper limit of the range with a 100 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_upper_limit?: number;
    /**
     * The upper limit of the range with a 95 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_upper_95PPR?: number;
    /**
     * The upper limit of the range with a 68 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_upper_68PPR?: number;
    /**
     * The most likely value for the usage rate; the expected increase or decrease of the fill_level per second. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_expected: number;
    /**
     * The lower limit of the range with a 68 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_lower_68PPR?: number;
    /**
     * The lower limit of the range with a 95 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_lower_95PPR?: number;
    /**
     * The lower limit of the range with a 100 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_lower_limit?: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$g = string;
/**
 * The role of the sender of this message
 */
type EnergyManagementRole = "CEM" | "RM";
interface Handshake$1 {
    message_type: "Handshake";
    message_id: ID$g;
    role: EnergyManagementRole;
    /**
     * Protocol versions supported by the sender of this message. This field is mandatory for the RM, but optional for the CEM.
     *
     * @minItems 1
     */
    supported_protocol_versions?: [string, ...string[]];
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$f = string;
interface HandshakeResponse$1 {
    message_type: "HandshakeResponse";
    message_id: ID$f;
    /**
     * The protocol version the CEM selected for this session
     */
    selected_protocol_version: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$e = string;
/**
 * ID of this instruction (as provided by the CEM)
 */
type ID1$5 = string;
/**
 * Present status of this instruction.
 */
type InstructionStatus = "NEW" | "ACCEPTED" | "REJECTED" | "REVOKED" | "STARTED" | "SUCCEEDED" | "ABORTED";
interface InstructionStatusUpdate$1 {
    message_type: "InstructionStatusUpdate";
    message_id: ID$e;
    instruction_id: ID1$5;
    status_type: InstructionStatus;
    /**
     * Timestamp when status_type has changed the last time.
     */
    timestamp: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$d = string;
/**
 * Duration of the PowerForecastElement
 */
type Duration$4 = number;
/**
 * The power quantity the value refers to
 */
type CommodityQuantity$2 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface PowerForecast$1 {
    message_type: "PowerForecast";
    message_id: ID$d;
    /**
     * Start time of time period that is covered by the profile.
     */
    start_time: string;
    /**
     * Elements of which this forecast consists. Contains at least one element. Elements must be placed in chronological order.
     *
     * @minItems 1
     * @maxItems 288
     */
    elements: [PowerForecastElement$1, ...PowerForecastElement$1[]];
}
interface PowerForecastElement$1 {
    duration: Duration$4;
    /**
     * The values of power that are expected for the given period of time. There shall be at least one PowerForecastValue, and at most one PowerForecastValue per CommodityQuantity.
     *
     * @minItems 1
     * @maxItems 10
     */
    power_values: [PowerForecastValue$1] | [PowerForecastValue$1, PowerForecastValue$1] | [PowerForecastValue$1, PowerForecastValue$1, PowerForecastValue$1] | [PowerForecastValue$1, PowerForecastValue$1, PowerForecastValue$1, PowerForecastValue$1] | [PowerForecastValue$1, PowerForecastValue$1, PowerForecastValue$1, PowerForecastValue$1, PowerForecastValue$1] | [
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1
    ] | [
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1
    ] | [
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1
    ] | [
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1
    ] | [
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1,
        PowerForecastValue$1
    ];
}
interface PowerForecastValue$1 {
    /**
     * The upper boundary of the range with 100 % certainty the power value is in it
     */
    value_upper_limit?: number;
    /**
     * The upper boundary of the range with 95 % certainty the power value is in it
     */
    value_upper_95PPR?: number;
    /**
     * The upper boundary of the range with 68 % certainty the power value is in it
     */
    value_upper_68PPR?: number;
    /**
     * The expected power value.
     */
    value_expected: number;
    /**
     * The lower boundary of the range with 68 % certainty the power value is in it
     */
    value_lower_68PPR?: number;
    /**
     * The lower boundary of the range with 95 % certainty the power value is in it
     */
    value_lower_95PPR?: number;
    /**
     * The lower boundary of the range with 100 % certainty the power value is in it
     */
    value_lower_limit?: number;
    commodity_quantity: CommodityQuantity$2;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$c = string;
/**
 * The power quantity the value refers to
 */
type CommodityQuantity$1 = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface PowerMeasurement$1 {
    message_type: "PowerMeasurement";
    message_id: ID$c;
    /**
     * Timestamp when PowerValues were measured.
     */
    measurement_timestamp: string;
    /**
     * Array of measured PowerValues. Must contain at least one item and at most one item per ‘commodity_quantity’ (defined inside the PowerValue).
     *
     * @minItems 1
     * @maxItems 10
     */
    values: [PowerValue] | [PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue, PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue] | [PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue, PowerValue] | [
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue,
        PowerValue
    ];
}
interface PowerValue {
    commodity_quantity: CommodityQuantity$1;
    /**
     * Power value expressed in the unit associated with the CommodityQuantity
     */
    value: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * The message this ReceptionStatus refers to
 */
type ID$b = string;
/**
 * Enumeration of status values
 */
type ReceptionStatusValues = "INVALID_DATA" | "INVALID_MESSAGE" | "INVALID_CONTENT" | "TEMPORARY_ERROR" | "PERMANENT_ERROR" | "OK";
interface ReceptionStatus$1 {
    message_type: "ReceptionStatus";
    subject_message_id: ID$b;
    status: ReceptionStatusValues;
    /**
     * Diagnostic label that can be used to provide additional information for debugging. However, not for HMI purposes.
     */
    diagnostic_label?: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$a = string;
/**
 * Identifier of the Resource Manager. Must be unique within the scope of the CEM.
 */
type ID1$4 = string;
/**
 * Role type of the Resource Manager for the given commodity
 */
type RoleType = "ENERGY_PRODUCER" | "ENERGY_CONSUMER" | "ENERGY_STORAGE";
/**
 * Commodity the role refers to.
 */
type Commodity = "GAS" | "HEAT" | "ELECTRICITY" | "OIL";
/**
 * The average time the combination of Resource Manager and HBES/BACS/SASS or (Smart) device needs to process and execute an instruction
 */
type Duration$3 = number;
/**
 * POWER_ENVELOPE_BASED_CONTROL: Identifier for the Power Envelope Based Control type
 * POWER_PROFILE_BASED_CONTROL: Identifier for the Power Profile Based Control type
 * OPERATION_MODE_BASED_CONTROL: Identifier for the Operation Mode Based Control type
 * FILL_RATE_BASED_CONTROL: Identifier for the Demand Driven Based Control type
 * DEMAND_DRIVEN_BASED_CONTROL: Identifier for the Fill Rate Based Control type
 * NOT_CONTROLABLE: Identifier that is to be used if no control is possible. Resources of this type can still provide measurements and forecast
 * NO_SELECTION: Identifier that is to be used if no control type is or has been selected.
 */
type ControlType$1 = "POWER_ENVELOPE_BASED_CONTROL" | "POWER_PROFILE_BASED_CONTROL" | "OPERATION_MODE_BASED_CONTROL" | "FILL_RATE_BASED_CONTROL" | "DEMAND_DRIVEN_BASED_CONTROL" | "NOT_CONTROLABLE" | "NO_SELECTION";
/**
 * Currency to be used for all information regarding costs. Mandatory if cost information is published.
 */
type Currency = "AED" | "ANG" | "AUD" | "CHE" | "CHF" | "CHW" | "EUR" | "GBP" | "LBP" | "LKR" | "LRD" | "LSL" | "LYD" | "MAD" | "MDL" | "MGA" | "MKD" | "MMK" | "MNT" | "MOP" | "MRO" | "MUR" | "MVR" | "MWK" | "MXN" | "MXV" | "MYR" | "MZN" | "NAD" | "NGN" | "NIO" | "NOK" | "NPR" | "NZD" | "OMR" | "PAB" | "PEN" | "PGK" | "PHP" | "PKR" | "PLN" | "PYG" | "QAR" | "RON" | "RSD" | "RUB" | "RWF" | "SAR" | "SBD" | "SCR" | "SDG" | "SEK" | "SGD" | "SHP" | "SLL" | "SOS" | "SRD" | "SSP" | "STD" | "SYP" | "SZL" | "THB" | "TJS" | "TMT" | "TND" | "TOP" | "TRY" | "TTD" | "TWD" | "TZS" | "UAH" | "UGX" | "USD" | "USN" | "UYI" | "UYU" | "UZS" | "VEF" | "VND" | "VUV" | "WST" | "XAG" | "XAU" | "XBA" | "XBB" | "XBC" | "XBD" | "XCD" | "XOF" | "XPD" | "XPF" | "XPT" | "XSU" | "XTS" | "XUA" | "XXX" | "YER" | "ZAR" | "ZMW" | "ZWL";
/**
 * ELECTRIC.POWER.L1: Electric power described in Watt on phase 1. If a device utilizes only one phase it should always use L1.
 * ELECTRIC.POWER.L2: Electric power described in Watt on phase 2. Only applicable for 3 phase devices.
 * ELECTRIC.POWER.L3: Electric power described in Watt on phase 3. Only applicable for 3 phase devices.
 * ELECTRIC.POWER.3_PHASE_SYMMETRIC: Electric power described in Watt on when power is equally shared among the three phases. Only applicable for 3 phase devices.
 * NATURAL_GAS.FLOW_RATE: Gas flow rate described in liters per second
 * HYDROGEN.FLOW_RATE: Gas flow rate described in grams per second
 * HEAT.TEMPERATURE: Heat described in degrees Celsius
 * HEAT.FLOW_RATE: Flow rate of heat carrying gas or liquid in liters per second
 * HEAT.THERMAL_POWER: Thermal power in Watt
 * OIL.FLOW_RATE: Oil flow rate described in liters per hour
 */
type CommodityQuantity = "ELECTRIC.POWER.L1" | "ELECTRIC.POWER.L2" | "ELECTRIC.POWER.L3" | "ELECTRIC.POWER.3_PHASE_SYMMETRIC" | "NATURAL_GAS.FLOW_RATE" | "HYDROGEN.FLOW_RATE" | "HEAT.TEMPERATURE" | "HEAT.FLOW_RATE" | "HEAT.THERMAL_POWER" | "OIL.FLOW_RATE";
interface ResourceManagerDetails$1 {
    message_type: "ResourceManagerDetails";
    message_id: ID$a;
    resource_id: ID1$4;
    /**
     * Human readable name given by user
     */
    name?: string;
    /**
     * Each Resource Manager provides one or more energy Roles
     *
     * @minItems 1
     * @maxItems 3
     */
    roles: [Role] | [Role, Role] | [Role, Role, Role];
    /**
     * Name of Manufacturer
     */
    manufacturer?: string;
    /**
     * Name of the model of the device (provided by the manufacturer)
     */
    model?: string;
    /**
     * Serial number of the device (provided by the manufacturer)
     */
    serial_number?: string;
    /**
     * Version identifier of the firmware used in the device (provided by the manufacturer)
     */
    firmware_version?: string;
    instruction_processing_delay: Duration$3;
    /**
     * The control types supported by this Resource Manager.
     *
     * @minItems 1
     * @maxItems 5
     */
    available_control_types: [ControlType$1] | [ControlType$1, ControlType$1] | [ControlType$1, ControlType$1, ControlType$1] | [ControlType$1, ControlType$1, ControlType$1, ControlType$1] | [ControlType$1, ControlType$1, ControlType$1, ControlType$1, ControlType$1];
    currency?: Currency;
    /**
     * Indicates whether the ResourceManager is able to provide PowerForecasts
     */
    provides_forecast: boolean;
    /**
     * Array of all CommodityQuantities that this Resource Manager can provide measurements for.
     *
     * @minItems 1
     * @maxItems 10
     */
    provides_power_measurement_types: [CommodityQuantity] | [CommodityQuantity, CommodityQuantity] | [CommodityQuantity, CommodityQuantity, CommodityQuantity] | [CommodityQuantity, CommodityQuantity, CommodityQuantity, CommodityQuantity] | [CommodityQuantity, CommodityQuantity, CommodityQuantity, CommodityQuantity, CommodityQuantity] | [CommodityQuantity, CommodityQuantity, CommodityQuantity, CommodityQuantity, CommodityQuantity, CommodityQuantity] | [
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity
    ] | [
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity
    ] | [
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity
    ] | [
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity,
        CommodityQuantity
    ];
}
interface Role {
    role: RoleType;
    commodity: Commodity;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$9 = string;
/**
 * The type of object that needs to be revoked
 */
type RevokableObjects = "PEBC.PowerConstraints" | "PEBC.EnergyConstraint" | "PEBC.Instruction" | "PPBC.PowerProfileDefinition" | "PPBC.ScheduleInstruction" | "PPBC.StartInterruptionInstruction" | "PPBC.EndInterruptionInstruction" | "OMBC.SystemDescription" | "OMBC.Instruction" | "FRBC.SystemDescription" | "FRBC.Instruction" | "DDBC.SystemDescription" | "DDBC.Instruction";
/**
 * The ID of object that needs to be revoked
 */
type ID1$3 = string;
interface RevokeObject$1 {
    message_type: "RevokeObject";
    message_id: ID$9;
    object_type: RevokableObjects;
    object_id: ID1$3;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$8 = string;
/**
 * The ControlType to activate. Must be one of the available ControlTypes as defined in the ResourceManagerDetails
 */
type ControlType = "POWER_ENVELOPE_BASED_CONTROL" | "POWER_PROFILE_BASED_CONTROL" | "OPERATION_MODE_BASED_CONTROL" | "FILL_RATE_BASED_CONTROL" | "DEMAND_DRIVEN_BASED_CONTROL" | "NOT_CONTROLABLE" | "NO_SELECTION";
interface SelectControlType$1 {
    message_type: "SelectControlType";
    message_id: ID$8;
    control_type: ControlType;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$7 = string;
/**
 * The type of request
 */
type SessionRequestType = "RECONNECT" | "TERMINATE";
interface SessionRequest$1 {
    message_type: "SessionRequest";
    message_id: ID$7;
    request: SessionRequestType;
    /**
     * Optional field for a human readible descirption for debugging purposes
     */
    diagnostic_label?: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$6 = string;
/**
 * ID of the actuator this messages refers to
 */
type ID1$2 = string;
/**
 * ID of the FRBC.OperationMode that is presently active.
 */
type ID2$2 = string;
/**
 * ID of the FRBC.OperationMode that was active before the present one. This value shall always be provided, unless the active FRBC.OperationMode is the first FRBC.OperationMode the Resource Manager is aware of.
 */
type ID3$1 = string;
interface FRBC_ActuatorStatus {
    message_type: "FRBC.ActuatorStatus";
    message_id: ID$6;
    actuator_id: ID1$2;
    active_operation_mode_id: ID2$2;
    /**
     * The number indicates the factor with which the FRBC.OperationMode is configured. The factor should be greater than or equal than 0 and less or equal to 1.
     */
    operation_mode_factor: number;
    previous_operation_mode_id?: ID3$1;
    /**
     * Time at which the transition from the previous FRBC.OperationMode to the active FRBC.OperationMode was initiated. This value shall always be provided, unless the active FRBC.OperationMode is the first FRBC.OperationMode the Resource Manager is aware of.
     */
    transition_timestamp?: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$5 = string;
/**
 * The duration of the element.
 */
type Duration$2 = number;
interface FRBC_FillLevelTargetProfile {
    message_type: "FRBC.FillLevelTargetProfile";
    message_id: ID$5;
    /**
     * Time at which the FRBC.FillLevelTargetProfile starts.
     */
    start_time: string;
    /**
     * List of different fill levels that have to be targeted within a given duration. There shall be at least one element. Elements must be placed in chronological order.
     *
     * @minItems 1
     * @maxItems 288
     */
    elements: [FRBC_FillLevelTargetProfileElement, ...FRBC_FillLevelTargetProfileElement[]];
}
interface FRBC_FillLevelTargetProfileElement {
    duration: Duration$2;
    fill_level_range: NumberRange$2;
}
/**
 * The target range in which the fill_level must be for the time period during which the element is active. The start of the range must be smaller or equal to the end of the range. The CEM must take best-effort actions to proactively achieve this target.
 */
interface NumberRange$2 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$4 = string;
/**
 * ID of the instruction. Must be unique in the scope of the Resource Manager, for at least the duration of the session between Resource Manager and CEM.
 */
type ID1$1 = string;
/**
 * ID of the actuator this instruction belongs to.
 */
type ID2$1 = string;
/**
 * ID of the FRBC.OperationMode that should be activated.
 */
type ID3 = string;
interface FRBC_Instruction {
    message_type: "FRBC.Instruction";
    message_id: ID$4;
    id: ID1$1;
    actuator_id: ID2$1;
    operation_mode: ID3;
    /**
     * The number indicates the factor with which the FRBC.OperationMode should be configured. The factor should be greater than or equal to 0 and less or equal to 1.
     */
    operation_mode_factor: number;
    /**
     * Indicates the moment the execution of the instruction shall start. When the specified execution time is in the past, execution must start as soon as possible.
     */
    execution_time: string;
    /**
     * Indicates if this is an instruction during an abnormal condition.
     */
    abnormal_condition: boolean;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$3 = string;
interface FRBC_LeakageBehaviour {
    message_type: "FRBC.LeakageBehaviour";
    message_id: ID$3;
    /**
     * Moment this FRBC.LeakageBehaviour starts to be valid. If the FRBC.LeakageBehaviour is immediately valid, the DateTimeStamp should be now or in the past.
     */
    valid_from: string;
    /**
     * List of elements that model the leakage behaviour of the buffer. The fill_level_ranges of the elements must be contiguous.
     *
     * @minItems 1
     * @maxItems 288
     */
    elements: [FRBC_LeakageBehaviourElement, ...FRBC_LeakageBehaviourElement[]];
}
interface FRBC_LeakageBehaviourElement {
    fill_level_range: NumberRange$1;
    /**
     * Indicates how fast the momentary fill level will decrease per second due to leakage within the given range of the fill level. A positive value indicates that the fill level decreases over time due to leakage.
     */
    leakage_rate: number;
}
/**
 * The fill level range for which this FRBC.LeakageBehaviourElement applies. The start of the range must be less than the end of the range.
 */
interface NumberRange$1 {
    /**
     * Number that defines the start of the range
     */
    start_of_range: number;
    /**
     * Number that defines the end of the range
     */
    end_of_range: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$2 = string;
interface FRBC_StorageStatus {
    message_type: "FRBC.StorageStatus";
    message_id: ID$2;
    /**
     * Present fill level of the Storage
     */
    present_fill_level: number;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID$1 = string;
/**
 * The ID of the timer this message refers to
 */
type ID1 = string;
/**
 * The ID of the actuator the timer belongs to
 */
type ID2 = string;
interface FRBC_TimerStatus {
    message_type: "FRBC.TimerStatus";
    message_id: ID$1;
    timer_id: ID1;
    actuator_id: ID2;
    /**
     * Indicates when the Timer will be finished. If the DateTimeStamp is in the future, the timer is not yet finished. If the DateTimeStamp is in the past, the timer is finished. If the timer was never started, the value can be an arbitrary DateTimeStamp in the past.
     */
    finished_at: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * ID of this message
 */
type ID = string;
/**
 * Indicator for how long the given usage_rate is valid.
 */
type Duration$1 = number;
interface FRBC_UsageForecast {
    message_type: "FRBC.UsageForecast";
    message_id: ID;
    /**
     * Time at which the FRBC.UsageForecast starts.
     */
    start_time: string;
    /**
     * Further elements that model the profile. There shall be at least one element. Elements must be placed in chronological order.
     *
     * @minItems 1
     * @maxItems 288
     */
    elements: [FRBC_UsageForecastElement, ...FRBC_UsageForecastElement[]];
}
interface FRBC_UsageForecastElement {
    duration: Duration$1;
    /**
     * The upper limit of the range with a 100 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_upper_limit?: number;
    /**
     * The upper limit of the range with a 95 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_upper_95PPR?: number;
    /**
     * The upper limit of the range with a 68 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_upper_68PPR?: number;
    /**
     * The most likely value for the usage rate; the expected increase or decrease of the fill_level per second. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_expected: number;
    /**
     * The lower limit of the range with a 68 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_lower_68PPR?: number;
    /**
     * The lower limit of the range with a 95 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_lower_95PPR?: number;
    /**
     * The lower limit of the range with a 100 % probability that the usage rate is within that range. A positive value indicates that the fill level will decrease due to usage.
     */
    usage_rate_lower_limit?: number;
}

interface ConstructorParameters$s {
    start_of_range: number;
    end_of_range: number;
    commodity_quantity: CommodityQuantity$a;
}
declare class PowerRange implements PowerRange$4 {
    start_of_range: number;
    end_of_range: number;
    commodity_quantity: CommodityQuantity$a;
    constructor({ start_of_range, end_of_range, commodity_quantity }: ConstructorParameters$s);
}

interface ConstructorParameters$r {
    message_id?: ID$l;
    role: EnergyManagementRole;
    supported_protocol_versions?: [string, ...string[]];
}
declare class Handshake implements Handshake$1 {
    message_type: 'Handshake';
    message_id: ID$l;
    role: EnergyManagementRole;
    supported_protocol_versions?: [string, ...string[]];
    constructor({ message_id, role, supported_protocol_versions }: ConstructorParameters$r);
}

interface ConstructorParameters$q {
    message_id?: ID$l;
    selected_protocol_version: string;
}
declare class HandshakeResponse implements HandshakeResponse$1 {
    message_type: "HandshakeResponse";
    message_id: ID$l;
    selected_protocol_version: string;
    constructor({ message_id, selected_protocol_version }: ConstructorParameters$q);
}

interface ConstructorParameters$p {
    message_id?: ID$l;
    instruction_id?: ID$l;
    status_type: InstructionStatus;
    timestamp: Timestamp;
}
declare class InstructionStatusUpdate implements InstructionStatusUpdate$1 {
    message_type: "InstructionStatusUpdate";
    message_id: ID$l;
    instruction_id: ID$l;
    status_type: InstructionStatus;
    timestamp: Timestamp;
    constructor({ message_id, instruction_id, status_type, timestamp }: ConstructorParameters$p);
}

interface ConstructorParameters$o {
    start_of_range: number;
    end_of_range: number;
}
declare class NumberRange implements NumberRange$9 {
    start_of_range: number;
    end_of_range: number;
    constructor({ start_of_range, end_of_range }: ConstructorParameters$o);
    Validate({ start_of_range, end_of_range }: ConstructorParameters$o): void;
}

type Duration = number;

type PowerForecastValuesArray = [PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3] | [PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3, PowerForecastValue$3];

type PowerValuesArray = [PowerValue$1] | [PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1] | [PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1, PowerValue$1];

type CommoditiesArray = [Commodity$3] | [Commodity$3, Commodity$3] | [Commodity$3, Commodity$3, Commodity$3] | [Commodity$3, Commodity$3, Commodity$3, Commodity$3];

interface ConstructorParameters$n {
    duration: Duration;
    power_values: PowerForecastValuesArray;
}
declare class PowerForecastElement implements PowerForecastElement$2 {
    duration: Duration;
    power_values: PowerForecastValuesArray;
    constructor({ duration, power_values }: ConstructorParameters$n);
}

interface ConstructorParameters$m {
    message_id?: ID$l;
    start_time: Timestamp;
    elements: [PowerForecastElement, ...PowerForecastElement[]];
}
declare class PowerForecast implements PowerForecast$1 {
    message_type: "PowerForecast";
    message_id: ID$l;
    start_time: Timestamp;
    elements: [PowerForecastElement, ...PowerForecastElement[]];
    constructor({ message_id, start_time, elements }: ConstructorParameters$m);
}

interface ConstructorParameters$l {
    value_upper_limit?: number;
    value_upper_95PPR?: number;
    value_upper_68PPR?: number;
    value_lower_68PPR?: number;
    value_lower_95PPR?: number;
    value_lower_limit?: number;
    value_expected: number;
    commodity_quantity: CommodityQuantity$a;
}
declare class PowerForecastValue implements PowerForecastValue$3 {
    value_upper_limit?: number;
    value_upper_95PPR?: number;
    value_upper_68PPR?: number;
    value_expected: number;
    value_lower_68PPR?: number;
    value_lower_95PPR?: number;
    value_lower_limit?: number;
    commodity_quantity: CommodityQuantity$a;
    constructor({ value_upper_limit, value_upper_95PPR, value_upper_68PPR, value_lower_68PPR, value_lower_95PPR, value_lower_limit, value_expected, commodity_quantity }: ConstructorParameters$l);
}

interface ConstructorParameters$k {
    message_id?: ID$l;
    measurement_timestamp: Timestamp;
    values: PowerValuesArray;
}
declare class PowerMeasurement implements PowerMeasurement$1 {
    message_type: "PowerMeasurement";
    message_id: ID$l;
    measurement_timestamp: Timestamp;
    values: PowerValuesArray;
    constructor({ message_id, measurement_timestamp, values }: ConstructorParameters$k);
}

interface ConstructorParameters$j {
    subject_message_id: ID$l;
    status: ReceptionStatusValues;
    diagnostic_label?: string;
}
declare class ReceptionStatus implements ReceptionStatus$1 {
    message_type: "ReceptionStatus";
    subject_message_id: ID$l;
    status: ReceptionStatusValues;
    diagnostic_label?: string;
    constructor({ subject_message_id, status, diagnostic_label }: ConstructorParameters$j);
}

interface ConstructorParameters$i {
    message_id?: ID$l;
    resource_id: ID$l;
    name?: string;
    roles: [Role$1] | [Role$1, Role$1] | [Role$1, Role$1, Role$1];
    manufacturer?: string;
    model?: string;
    serial_number?: string;
    firmware_version?: string;
    instruction_processing_delay: Duration;
    available_control_types: [ControlType$2] | [ControlType$2, ControlType$2] | [ControlType$2, ControlType$2, ControlType$2] | [ControlType$2, ControlType$2, ControlType$2, ControlType$2] | [ControlType$2, ControlType$2, ControlType$2, ControlType$2, ControlType$2];
    currency?: Currency$1;
    provides_forecast: boolean;
    provides_power_measurement_types: [CommodityQuantity$a] | [CommodityQuantity$a, CommodityQuantity$a] | [CommodityQuantity$a, CommodityQuantity$a, CommodityQuantity$a];
}
declare class ResourceManagerDetails implements ResourceManagerDetails$1 {
    message_type: "ResourceManagerDetails";
    message_id: string;
    resource_id: string;
    name?: string;
    roles: [Role$1] | [Role$1, Role$1] | [Role$1, Role$1, Role$1];
    manufacturer?: string;
    model?: string;
    serial_number?: string;
    firmware_version?: string;
    instruction_processing_delay: Duration;
    available_control_types: [ControlType$2] | [ControlType$2, ControlType$2] | [ControlType$2, ControlType$2, ControlType$2] | [ControlType$2, ControlType$2, ControlType$2, ControlType$2] | [ControlType$2, ControlType$2, ControlType$2, ControlType$2, ControlType$2];
    currency?: Currency$1;
    provides_forecast: boolean;
    provides_power_measurement_types: [CommodityQuantity$a] | [CommodityQuantity$a, CommodityQuantity$a] | [CommodityQuantity$a, CommodityQuantity$a, CommodityQuantity$a];
    constructor({ message_id, resource_id, name, roles, manufacturer, model, serial_number, firmware_version, instruction_processing_delay, available_control_types, currency, provides_forecast, provides_power_measurement_types }: ConstructorParameters$i);
}

interface ConstructorParameters$h {
    message_id?: ID$l;
    object_type: RevokableObjects;
    object_id: ID$l;
}
declare class RevokeObject implements RevokeObject$1 {
    message_type: "RevokeObject";
    message_id: ID$l;
    object_type: RevokableObjects;
    object_id: ID$l;
    constructor({ message_id, object_type, object_id }: ConstructorParameters$h);
}

interface ConstructorParameters$g {
    message_id?: ID$l;
    control_type: ControlType;
}
declare class SelectControlType implements SelectControlType$1 {
    message_type: "SelectControlType";
    message_id: ID$l;
    control_type: ControlType;
    constructor({ message_id, control_type }: ConstructorParameters$g);
}

interface ConstructorParameters$f {
    message_id?: ID$l;
    request: SessionRequestType;
    diagnostic_label?: string;
}
declare class SessionRequest implements SessionRequest$1 {
    message_type: "SessionRequest";
    message_id: ID$l;
    request: SessionRequestType;
    diagnostic_label?: string;
    constructor({ message_id, request, diagnostic_label }: ConstructorParameters$f);
}

interface ConstructorParameters$e {
    id?: ID$l;
    duration: Duration;
    diagnostic_label?: string;
}
declare class Timer implements Timer$2 {
    id: ID$l;
    diagnostic_label?: string;
    duration: Duration;
    constructor({ id, duration, diagnostic_label }: ConstructorParameters$e);
}

interface ConstructorParameters$d {
    id?: ID$l;
    from: ID$l;
    to: ID$l;
    start_timers: ID$l[];
    blocking_timers: ID$l[];
    transition_costs?: number;
    transition_duration?: Duration;
    abnormal_condition_only: boolean;
}
declare class Transition implements Transition$2 {
    id: ID$l;
    from: ID$l;
    to: ID$l;
    start_timers: ID$l[];
    blocking_timers: ID$l[];
    transition_costs?: number;
    transition_duration?: Duration;
    abnormal_condition_only: boolean;
    constructor({ id, from, to, start_timers, blocking_timers, transition_costs, transition_duration, abnormal_condition_only }: ConstructorParameters$d);
}

type Timestamp = string;

interface ConstructorParameters$c {
    id?: ID$l;
    diagnostic_label?: string;
    supported_commodities: CommoditiesArray;
    operation_modes: [FRBC_OperationMode, ...FRBC_OperationMode[]];
    transitions: Transition$2[];
    timers: Timer$2[];
}
declare class FrbcActuatorDescription implements FRBC_ActuatorDescription {
    id: ID$l;
    diagnostic_label?: string;
    supported_commodities: CommoditiesArray;
    operation_modes: [FRBC_OperationMode, ...FRBC_OperationMode[]];
    transitions: Transition$2[];
    timers: Timer$2[];
    constructor({ id, supported_commodities, operation_modes, transitions, timers, diagnostic_label }: ConstructorParameters$c);
}

type FrbcOperationModeFactor = number;

interface ConstructorParameters$b {
    message_id?: ID$l;
    actuator_id: ID$l;
    active_operation_mode_id: ID$l;
    operation_mode_factor: FrbcOperationModeFactor;
    previous_operation_mode_id?: ID$l;
    transition_timestamp?: Timestamp;
}
declare class FrbcActuatorStatus implements FRBC_ActuatorStatus {
    message_type: "FRBC.ActuatorStatus";
    message_id: ID$l;
    actuator_id: ID$l;
    active_operation_mode_id: ID$l;
    operation_mode_factor: FrbcOperationModeFactor;
    previous_operation_mode_id?: ID$l;
    transition_timestamp?: Timestamp;
    constructor({ message_id, actuator_id, active_operation_mode_id, operation_mode_factor, previous_operation_mode_id, transition_timestamp }: ConstructorParameters$b);
}

interface ConstructorParameters$a {
    message_id?: string;
    start_time: Timestamp;
    elements: [FrbcFillLevelTargetProfileElement, ...FrbcFillLevelTargetProfileElement[]];
}
declare class FrbcFillLevelTargetProfile implements FRBC_FillLevelTargetProfile {
    message_type: "FRBC.FillLevelTargetProfile";
    message_id: string;
    start_time: Timestamp;
    elements: [FrbcFillLevelTargetProfileElement, ...FrbcFillLevelTargetProfileElement[]];
    constructor({ message_id, start_time, elements }: ConstructorParameters$a);
}

interface ConstructorParameters$9 {
    duration: Duration;
    fill_level_range: NumberRange;
}
declare class FrbcFillLevelTargetProfileElement implements FRBC_FillLevelTargetProfileElement$1 {
    duration: Duration;
    fill_level_range: NumberRange;
    constructor({ duration, fill_level_range }: ConstructorParameters$9);
}

interface ConstructorParameters$8 {
    message_id?: ID$l;
    id: ID$l;
    actuator_id: ID$l;
    operation_mode: ID$l;
    operation_mode_factor: FrbcOperationModeFactor;
    execution_time: Timestamp;
    abnormal_condition: boolean;
}
declare class FrbcInstruction implements FRBC_Instruction {
    message_type: "FRBC.Instruction";
    message_id: ID$l;
    id: ID$l;
    actuator_id: ID$l;
    operation_mode: ID$l;
    operation_mode_factor: FrbcOperationModeFactor;
    execution_time: Timestamp;
    abnormal_condition: boolean;
    constructor({ message_id, id, actuator_id, operation_mode, operation_mode_factor, execution_time, abnormal_condition }: ConstructorParameters$8);
}

interface ConstructorParameters$7 {
    message_id?: ID$l;
    valid_from: Timestamp;
    elements: [FrbcLeakageBehaviourElement, ...FrbcLeakageBehaviourElement[]];
}
declare class FrbcLeakageBehaviour implements FRBC_LeakageBehaviour {
    message_type: "FRBC.LeakageBehaviour";
    message_id: ID$l;
    valid_from: Timestamp;
    elements: [FrbcLeakageBehaviourElement, ...FrbcLeakageBehaviourElement[]];
    constructor({ message_id, valid_from, elements }: ConstructorParameters$7);
}

interface ConstructorParameters$6 {
    fill_level_range: NumberRange;
    leakage_rate: number;
}
declare class FrbcLeakageBehaviourElement implements FRBC_LeakageBehaviourElement$1 {
    fill_level_range: NumberRange;
    leakage_rate: number;
    constructor({ fill_level_range, leakage_rate }: ConstructorParameters$6);
}

interface ConstructorParameters$5 {
    id?: ID$l;
    elements: [FRBC_OperationModeElement, ...FRBC_OperationModeElement[]];
    abnormal_condition_only: boolean;
}
declare class FrbcOperationMode implements FRBC_OperationMode {
    id: ID$l;
    diagnostic_label?: string;
    elements: [FRBC_OperationModeElement, ...FRBC_OperationModeElement[]];
    abnormal_condition_only: boolean;
    constructor({ id, elements, abnormal_condition_only }: ConstructorParameters$5);
}

interface ConstructorParameters$4 {
    diagnostic_label: string;
    fill_level_label: string;
    provides_leakage_behaviour: boolean;
    provides_fill_level_target_profile: boolean;
    provides_usage_forecast: boolean;
    fill_level_range: NumberRange;
}
declare class FrbcStorageDescription implements FRBC_StorageDescription {
    diagnostic_label?: string;
    fill_level_label?: string;
    provides_leakage_behaviour: boolean;
    provides_fill_level_target_profile: boolean;
    provides_usage_forecast: boolean;
    fill_level_range: NumberRange;
    constructor({ diagnostic_label, fill_level_label, provides_leakage_behaviour, provides_fill_level_target_profile, provides_usage_forecast, fill_level_range }: ConstructorParameters$4);
}

interface ConstructorParameters$3 {
    message_id?: ID$l;
    present_fill_level: number;
}
declare class FrbcStorageStatus implements FRBC_StorageStatus {
    message_type: "FRBC.StorageStatus";
    message_id: ID$l;
    present_fill_level: number;
    constructor({ message_id, present_fill_level }: ConstructorParameters$3);
}

interface ConstructorParameters$2 {
    message_id?: ID$l;
    timer_id: ID$l;
    actuator_id: ID$l;
    finished_at: Timestamp;
}
declare class FrbcTimerStatus implements FRBC_TimerStatus {
    message_type: "FRBC.TimerStatus";
    message_id: ID$l;
    timer_id: ID$l;
    actuator_id: ID$l;
    finished_at: Timestamp;
    constructor({ message_id, timer_id, actuator_id, finished_at }: ConstructorParameters$2);
}

interface ConstructorParameters$1 {
    duration: Duration;
    usage_rate_upper_limit?: number;
    usage_rate_upper_95PPR?: number;
    usage_rate_upper_68PPR?: number;
    usage_rate_expected: number;
    usage_rate_lower_68PPR?: number;
    usage_rate_lower_95PPR?: number;
    usage_rate_lower_limit?: number;
}
declare class FrbcUsageForecastElement implements FRBC_UsageForecastElement$1 {
    duration: Duration;
    usage_rate_upper_limit?: number;
    usage_rate_upper_95PPR?: number;
    usage_rate_upper_68PPR?: number;
    usage_rate_expected: number;
    usage_rate_lower_68PPR?: number;
    usage_rate_lower_95PPR?: number;
    usage_rate_lower_limit?: number;
    constructor({ duration, usage_rate_upper_limit, usage_rate_upper_95PPR, usage_rate_upper_68PPR, usage_rate_expected, usage_rate_lower_68PPR, usage_rate_lower_95PPR, usage_rate_lower_limit, }: ConstructorParameters$1);
}

interface ConstructorParameters {
    message_id?: ID$l;
    start_time: Timestamp;
    elements: [FrbcUsageForecastElement, ...FrbcUsageForecastElement[]];
}
declare class FrbcUsageForecast implements FRBC_UsageForecast {
    message_type: "FRBC.UsageForecast";
    message_id: ID$l;
    start_time: Timestamp;
    elements: [FrbcUsageForecastElement, ...FrbcUsageForecastElement[]];
    constructor({ message_id, start_time, elements }: ConstructorParameters);
}

export { type CommodityQuantity$a as CommodityQuantity, type EnergyManagementRole, FrbcActuatorDescription, FrbcActuatorStatus, FrbcFillLevelTargetProfile, FrbcInstruction, FrbcLeakageBehaviour, FrbcOperationMode, FrbcStorageDescription, FrbcStorageStatus, FrbcTimerStatus, FrbcUsageForecast, Handshake, HandshakeResponse, InstructionStatusUpdate, NumberRange, PowerForecast, PowerForecastValue, PowerMeasurement, PowerRange, ReceptionStatus, ResourceManagerDetails, RevokeObject, SelectControlType, SessionRequest, Timer, Transition, WebSocketClientController, WebSocketServerController, init, parseMessage };
